# Task 2 Deadlock Detection

在阻塞过程中有可能会出现多个事务的循环等待，而循环等待会造成死锁。在 Bustub 中我们采用一个 `background Deadlock Detection`  线程来定时检查当前是否出现死锁。

我们用 ` wait for`  图来表示事务之间的等待关系。wait for 是一个有向图，t1->t2 即代表 t1 事务正在等待 t2 事务释放资源。当 wait for 图中存在环时，即代表出现死锁，需要挑选事务终止以打破死锁。

我们并不需要时刻维护 wait for 图，而是在死锁检测线程被唤醒时，根据当前请求队列构建 wait for 图，再通过 wait for 图判断是否存在死锁。当判断完成后，将丢弃当前 wait for 图。下次线程被唤醒时再重新构建。

最常见的有向图环检测算法包括 DFS 和拓扑排序。在这里我们选用 ` DFS ` 来进行环检测。构建 wait for 图时要保证搜索的确定性。始终从 tid 较小的节点开始搜索，在选择邻居时，也要优先搜索 tid 较小的邻居。

构建 wait for 图的过程是，遍历 table_lock_map 和 row_lock_map 中所有的请求队列，对于每一个请求队列，用一个二重循环将所有满足等待关系的一对 tid 加入 wait for 图的边集。满足等待关系是指，对于两个事务 a 和 b，a 是 waiting 请求，b 是 granted 请求，则生成 a->b 一条边。

在成功构建 wait for 图后，对 wait for 图实施环检测算法。具体的算法就不说了，正好可以复习复习有向图环检测。有一点需要注意，这个环检测算法不仅需要输出是否存在环，假如存在环，还要输出环上的所有节点。因为之后我们需要在这些成环的节点里挑选合适的事务进行终止。